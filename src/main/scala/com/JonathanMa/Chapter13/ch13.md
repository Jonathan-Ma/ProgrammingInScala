### Chapter 13

## Packages and Imports
It is important to minimize *coupling* -- the extent to which the various parts
of the program rely on the other parts.

### 13.1 Putting code in packages

You can place contents of an entire file into a package by putting package clause at the top
of the file

    package bobsrocket.navigation
    class Navigator
#### Listing 13.1

We can also package using curly braces so we can put different parts of a file
in different packages:
    
    package bobsrocket{
       package navigation{
            // In package bobsrockets.navigation
            class Navigator

            package tests {
                // In package bobsrocket.navigation.tests
                class NavigatorSuite
            }
        }
    }
#### Listing 13.3
    package bobsrockets {
        package navigation {
            class Navigator {
                // No need to say bobsrockets.navigation.StarMap
                val map = new StarMap
            }
            class StarMap
        }
        class Ship {
            // No need to say bobsrockets.navigation.Navigator
            val nav = new navigation.Navigator
        }
        package fleets {
            class Fleet {
                // No need to say bobsrockets.Ship
                def addShip() = { new Ship }
            }
        }
    }
#### Listing 13.4
### 13.2 Concise access to related code
Listing 13.4 gives three simple examples:

- First, a class can be accessed directly from within the same package without a prefix.

- Second, a package itself can be accessed from its containing package without a prefix.

- Third, all names accessible in scopes outside the packaging are also available inside it.

This kind of access is only available if you explicitly nest packaging. 


    
    package bobsrockets {
        class Ship
    }
    package bobsrockets.fleets {
        class Fleet {
            // Doesn't compile! Ship is not in scope.
            def addShip() = { new Ship }
        }
    }

#### Listing 13.5

In Listing 13.5, we moved bobsrockets.fleets to the top level. Since its no longer enclosed
in bobsrockets package, then names in bobsrockets are not in scope and therefore cannot be 
directly accessed, hence, new Ship will not compile.

### 13.3 Imports
Import clause makes package members and objects accessible by name without needing to add prefix.

    package bobsdelights
    abstract class Fruit(
        val name: String,
        val color: String
    )
    object Fruits {
        object Apple extends Fruit("apple", "red")
        object Orange extends Fruit("orange", "orange")
        object Pear extends Fruit("pear", "yellowish")
        val menu = List(Apple, Orange, Pear)
    }
#### Listing 13.7

Consider